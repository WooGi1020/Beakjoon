---
tistoryBlogName: coding-woogi
tistoryTitle: _컴퓨터 구조_ CPU 성능 향상 기법
tistoryVisibility: "0"
tistoryCategory: "1408365"
tistorySkipModal: true
tistoryPostId: "15"
tistoryPostUrl: https://coding-woogi.tistory.com/15
---
### 05-1 빠른 CPU를 위한 설계 기법

- 클럭
	클럭신호가 높을 수록 CPU의 성능 증가
```CSs
클럭속도(Hz)
	초단위로 반복되는 클럭을 측정하는 단위
	높을 수록 성능이 증가되는 것은 맞으나 너무 높이면 여러가지 문제발생
```
- 코어와 멀티코어
	CPU 안에서 ==명령을 실행하는 부품==으로서 사용됨
	-> 이러한 코어를 여러개 포함하는 CPU를 멀티코어 CPU or 프로세서라 칭함
```CSS
코어의 종류
- 코어
	싱글코어(1)
- 멀티코어
	듀얼코어(2)
	트리플코어(3)
	쿼드코어(4)
	헥사코어(6)
	옥타코어(8)
	데카코어(10)
	도데카코어(12)

클럭속도의 개념과 비슷하게 무조건 늘린다고 좋은 것은 아님.
코어마다 처리할 명령어의 적절한 분배가 연산 속도의 관건
```
- 스레드와 멀티스레드
	스레드는 ==실행 흐름의 단위==를 칭하는 단어
	-> 하나의 코어로 여러 명령어를 동시에 처리하는 CPU를 멀티스레드 CPU or 프로세서라 칭함
	ex) 인텔의 멀티스레드 기술인 '하이퍼스레딩'
```CSS
스레드
- 하드웨어적 스레드 (논리 프로세서)
	하나의 코어가 동시에 처리하는 명령어 단위를 지칭함
- 소프트웨어적 스레드
	하나의 프로그램에서 독립적으로 실행되는 단위를 지칭함

ex) 1코어 1스레드 CPU는 스레드(소프트웨어)를 수십개 실행할 수 있다.(총괄의미)

멀티스레드 프로세서
	실제 설계를 위해 다양한 레지스터를 필요로 함
	ex) 2코어 4스레드의 경우 한번의 4개의 명령어를 처리하는데 CPU가 4개 있는 것과 같은 의미
```

---
### 05-2 명령어 병렬 처리 기법

- 대표적 명령어 처리 기법
	명령어 파이프라이닝
	슈퍼스칼라
	비순차적 명령어 처리
```CSS
명령어 파이프라인
	1. 명령어 인출
	2. 명령어 해석
	3. 명령어 실행
	4. 결과 저장
	-> 단계가 겹치지 않을 시, CPU는 각 단계를 '동시'에 실행 가능
```

- 파이프라인 위험(명령어 파이프라인에 따른 성능향상의 실패)
	데이터 위험 : 명령어 간 ==데이터의존성==에 의해 발생
	```CSS
	ex) 명령어1 : R1 <- R2 + R3 // R2레지스터값 + R3레지스터값
		명령어2 : R4 <- R1 + R5 // R1레지스터값 + R5레지스터값
	-> 이와 같이 이전 명령어 실행을 완료해야 다음 명령어를 실행 가능한 경우
```
	제어 위험 : 분기 등에 의한 ==프로그램 카운터의 갑작스런 변화==에 의해 발생
	```CSS
	기본적으로 프로그램 카운터는 '현재 실행 중인 명령어의 다음 주소'로 갱신
	실행 흐름의 변화로 이에 변화가 생기면 미리 가지고온 명령어들은 쓸모X
```
	구조적 위험 : 명령어들을 겹쳐 실행하는 과정에서 서로다른 명령어가 동시에 CPU 부품을 사용하려고 할 때 발생

- 슈퍼 스칼라
	CPU 내부에 여러 개의 명령어 파이프라인을 포함한 구조를 지칭
	=> "공장 생산 라인 증감"
	이러한 구조로 명령어 처리가 가능한 CPU를 ==슈퍼스칼라 프로세서 or CPU==라 칭함
	프로그램 처리 속도 -> 파이프라인 개수에 비례

- 비순차적 명령어 처리(OoOE)
	명령어의 ==합법적인 새치기==라고도 할 수 있음
	위의 방법들은 전부 순차적 처리를 상정한 기법(예상치못한 문제로 처리되지 못할 경우 순차적이기 때문에 구동X)
	```CSS
	ex)
	1. M(100) <- 1
	2. M(101) <- 2
	3. M(102) <- M(100) + M(101)
	4. M(150) <- 1
	5. M(151) <- 2
	6. M(152) <- 3
	-> 위 명령어 처리 방식이 순차적일 경우 3번을 실행하기 위해 1, 2번을 기다려야함
	-> 비순차적으로 처리하는 경우, 3번을 실행하기 위한 명령어는 1, 2번뿐이므로 4,5,6번 선처리
```
-> 이러한 매커니즘을 토대로 순서를 바꿔 실행해도(데이터 의존성X, 전 명령어 연관X) 무방한 명령어를 선 처리하여 ==파이프라인이 멈추는 것을 방지==

---

### 05-3 CISC와 RISC

==파이프라이닝 하기 쉬운 명령어==를 지향하는 CPU의 언어 ISA, 각기 다른 성격의 ISA 기반 CISC, RISC

- 명령어 집합(ISA)
	각각의 CPU가 이해할 수 있는 명령어들의 모음(CPU마다 ISA가 다르다는 것을 암시)
	==ISA의 차이에 따른 CPU 특징의 다양한 차이==

- CISC
	복잡한 명령어 집합을 활용하는 컴퓨터(CPU)
	x86, x86-64가 대표적인 CISC 기반 ISA
	```CSS
	다양하고 강력한 기능의 명령어 집합 활용 -> '가변 길이 명령어 활용'
	- 장점
		상대적으로 적은 수의 명령어로 프로그램 실행 가능
		-> 메모리 공간 절약
	- 단점
		활용 명령어의 복잡성과 다양성에 따른 일정하지 못한 실행주기
		하나의 명령어 실행에 여러 클럭주기를 필요로함.
		실제로 쓰이는 명령어만 계속 쓰임(명령어의 규격화가 어려움)
		-> 이는 명령어 파이프라인 구현을 방해하는 큰 요소(비일정성)
```

- RISC
	CISC의 한계를 보완
	```CSS
	CISC의 한계
	1. 빠른 처리를 위한 명령어 파이프라인 활용의 필요성(명령어의 길이, 수행시간 감소, 규격화)
	2. 자주 쓰이는 기본적인 명령어를 효율적으로 제작
```
	```CSS
	짧고 규격화된 명령어(되도록 1클럭 내외 실행 지향) -> '고정 길이 명령어 활용'
	명령어 파이프라이닝에 최적화
	
	메모리에 직접 접근하는 명령어를 load와 store 두개로 제한(메모리 접근의 단순화, 최소화)
	-> 레지스터의 적극적인 활용(레지스터 이용 연산, 범용 레지스터 개수의 증가)
```





